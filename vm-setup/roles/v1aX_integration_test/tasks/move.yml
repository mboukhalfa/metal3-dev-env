---
  - name: Define number of BMH's
    set_fact:
      NUMBER_OF_BMH: "{{ NUM_OF_MASTER_REPLICAS|int +  NUM_OF_WORKER_REPLICAS|int }}"

  - name: Remove ironic container from source cluster (Ephemeral Cluster is kind)
    docker_container:
      name: "{{ item }}"
      state: absent
    with_items:
       - ironic-api
       - ironic-conductor
       - ironic-inspector
       - dnsmasq
       - httpd
       - mariadb
       - ironic-endpoint-keepalived
       - ironic-log-watch
       - ironic-inspector-log-watch
    become: yes
    become_user: root
    when: EPHEMERAL_CLUSTER == "kind"

  - name: Remove Ironic from from source cluster (Ephemeral Cluster is minikube)
    k8s:
      name: metal3-ironic
      kind: Deployment
      state: absent
      namespace: "{{ NAMESPACE }}"
    when: EPHEMERAL_CLUSTER == "minikube"

  - name: Label BMO CRDs.
    shell: 'kubectl label --overwrite crds baremetalhosts.metal3.io {{ item }}'
    with_items:
       - clusterctl.cluster.x-k8s.io=""
       - cluster.x-k8s.io/provider="metal3"
    when: CAPM3_VERSION == "v1alpha3"

  - name: Fetch target cluster kubeconfig
    community.kubernetes.k8s_info:
      api_version: v1
      kind: Secret
      name: "{{ CLUSTER_NAME }}-kubeconfig"
      namespace: "{{ NAMESPACE }}"
    register: secret

  - local_action: 
      module: copy 
      content: "{{ secret | json_query('resources[*].data.value') | b64decode}}"
      dest: "{{ TARGET_KUBECONFIG }}"

  - name: Create namespace
    k8s:
      name: "{{ NAMESPACE }}"
      kind: Namespace
      state: present
      kubeconfig: "{{ TARGET_KUBECONFIG }}"

  # Install BMO
  - name: Install Baremetal Operator
    shell: "{{ BMOPATH }}/tools/deploy.sh true false {{ IRONIC_TLS_SETUP }} {{ IRONIC_BASIC_AUTH }} true"
    environment:
      IRONIC_HOST: "{{ IRONIC_HOST }}"
      IRONIC_HOST_IP: "{{ IRONIC_HOST_IP }}"
      KUBECTL_ARGS: "{{ KUBECTL_ARGS }}"
    when: CAPM3_VERSION == "v1alpha3"

  # Configure Ironic configmap
  - name: Configure Ironic Configmap
    shell: |
      cp {{ BMOPATH }}/ironic-deployment/keepalived/ironic_bmo_configmap.env {{ BMOPATH }}/ironic-deployment/keepalived/ironic_bmo_configmap.env.orig
      cp {{ IRONIC_DATA_DIR }}/ironic_bmo_configmap.env  {{ BMOPATH }}/ironic-deployment/keepalived/ironic_bmo_configmap.env

  # Install Ironic
  - name: Install Ironic
    shell: "{{ BMOPATH }}/tools/deploy.sh false true {{ IRONIC_TLS_SETUP }} {{ IRONIC_BASIC_AUTH }} true"
    environment:
      IRONIC_HOST: "{{ IRONIC_HOST }}"
      IRONIC_HOST_IP: "{{ IRONIC_HOST_IP }}"
      KUBECTL_ARGS: "{{ KUBECTL_ARGS }}"
 
  - name: Reinstate Ironic Configmap
    shell: "mv {{ BMOPATH }}/ironic-deployment/keepalived/ironic_bmo_configmap.env.orig {{ BMOPATH }}/ironic-deployment/keepalived/ironic_bmo_configmap.env"

  - name: Label BMO CRDs in target cluster.
    shell: 'kubectl --kubeconfig {{ TARGET_KUBECONFIG }} label crds baremetalhosts.metal3.io {{ item }} --overwrite '
    with_items:
      - clusterctl.cluster.x-k8s.io=""
      - cluster.x-k8s.io/provider="metal3"
    when: CAPM3_VERSION == "v1alpha3"

  - name: Initialize Provider component in target cluster
    shell: "clusterctl init --kubeconfig {{ TARGET_KUBECONFIG }} --core cluster-api:{{ CAPIRELEASE }} --bootstrap kubeadm:{{ CAPIRELEASE }} --control-plane kubeadm:{{ CAPIRELEASE }} --infrastructure metal3:{{ CAPM3RELEASE }} -v 5"

  # Check for pods & nodes on the target cluster
  - name: Wait until target cluster Pods are in Running state
    community.kubernetes.k8s_info:
      kind: Pod
      kubeconfig: "{{ TARGET_KUBECONFIG }}"
      field_selectors:
        - status.phase=Running
    retries: 150
    delay: 20
    register: running_pods
    failed_when: >
      (running_pods.stderr != "") or
      (running_pods.rc > 1) or
      (running_pods.stdout != "")
    until: running_pods.stdout == ""

  - name: Pivot objects to target cluster
    shell: "clusterctl move --to-kubeconfig {{ TARGET_KUBECONFIG }} -n {{ NAMESPACE }} -v 10"

  - name: Check if machines become running.
    shell: |
        kubectl get machines -n {{ NAMESPACE }} -o json | jq -r '[ .items[]
        | select (.status.phase == "Running" or .status.phase == "running")
        | .metadata.name ] | length'
    register: provisioned_machines
    environment:
      KUBECONFIG: "{{ TARGET_KUBECONFIG }}"
    retries: 50
    delay: 20
    until: provisioned_machines.stdout == NUMBER_OF_BMH

  - name: Check if metal3machines become provisioned.
    shell: |
        kubectl get m3m -n {{ NAMESPACE }} -o json | jq -r '[ .items[]
        | select (.status.ready == true)
        | .metadata.name ] | length'
    register: provisioned_m3m_machines
    environment:
      KUBECONFIG: "{{ TARGET_KUBECONFIG }}"
    retries: 10
    delay: 20
    until: provisioned_m3m_machines.stdout == NUMBER_OF_BMH

  - name: Check if bmh is in provisioned state
    shell: |
        kubectl get bmh -n {{ NAMESPACE }} -o json | jq -r '[ .items[]
        | select (.status.provisioning.state == "provisioned")
        | .metadata.name ] | length'
    environment:
      KUBECONFIG: "{{ TARGET_KUBECONFIG }}"
    register: provisioned_bmh
    retries: 10
    delay: 20
    until: provisioned_bmh.stdout ==  NUMBER_OF_BMH
